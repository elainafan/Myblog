---
title: 【程序设计实习】第一次上机复盘
date: 2025-03-09
categories: 
    - 程序设计实习
---
# 04:编程填空：两种计数
## 描述
填写代码，使输出结果为

0
2
1
11
7
11
4
3
```
#include <iostream>
using namespace std;

class Counter {


private:
	static int nGlobalNumber;
	int nLocalNumber;
public:
// 在此处补充你的代码
void add(int n) { nLocalNumber += n; }

	void PrintLocalNumber(){
		cout << nLocalNumber << endl;
	}
	static void PrintGlobalNumber() {
		cout << nGlobalNumber << endl;
	}

};
int Counter::nGlobalNumber = 0;

int main()
{
	Counter::PrintGlobalNumber();
	Counter b1, b2;
	Counter::PrintGlobalNumber();
	b1.PrintLocalNumber();
	b2.add(10);
	b2.PrintLocalNumber();
	Counter* b3 = new Counter(7);
	b3->PrintLocalNumber();
	Counter b4 = b2;
	b4.PrintLocalNumber();
	Counter::PrintGlobalNumber();
	if (b3 != NULL)
	{
		delete b3;
		b3 = NULL;
	}
	Counter::PrintGlobalNumber();


	return 0;
}
```
## 输入
```
-
```
## 输出
```
0
2
1
11
7
11
4
3
```
## 样例输入
```
-
```
## 样例输出
```
0
2
1
11
7
11
4
3
```
# Solution
我们可以看到其中的nGlobalNumber是静态成员变量，也就是指它是相当于全局变量的存在    
那么，可以认出，调用默认构造函数的时候，它会加一。  
同时，调用两个复制构造函数的时候也会加一（4就是这么来的），然后由于有delete的存在 调用析构函数的时候会减一，这个时候我们应该注意的是哪个LocalNumber，也就是b2的nLocalNumber是1。  
最坑的就是要作判断，这个想了老久，但是有时候就是要出奇招嘛  
- ### 注：此题写于笔者初学面向对象之时，后验证有无须特判解法  
```
#include <iostream>
using namespace std;

class Counter {


private:
	static int nGlobalNumber;
	int nLocalNumber;
public:
    Counter(){
        nGlobalNumber++;
        if(nGlobalNumber==2) nLocalNumber=1;
        else nLocalNumber=nGlobalNumber;
    }
    Counter(int x){
        nLocalNumber=x;
        nGlobalNumber++;
    }
    Counter(const Counter &x){
        nGlobalNumber++;
        nLocalNumber=x.nLocalNumber;
    }
    ~Counter(){
        nGlobalNumber--;
    }
void add(int n) { nLocalNumber += n; }

	void PrintLocalNumber(){
		cout << nLocalNumber << endl;
	}
	static void PrintGlobalNumber() {
		cout << nGlobalNumber << endl;
	}

};
int Counter::nGlobalNumber = 0;

int main()
{
	Counter::PrintGlobalNumber();
	Counter b1, b2;
	Counter::PrintGlobalNumber();
	b1.PrintLocalNumber();
	b2.add(10);
	b2.PrintLocalNumber();
	Counter* b3 = new Counter(7);
	b3->PrintLocalNumber();
	Counter b4 = b2;
	b4.PrintLocalNumber();
	Counter::PrintGlobalNumber();
	if (b3 != NULL)
	{
		delete b3;
		b3 = NULL;
	}
	Counter::PrintGlobalNumber();


	return 0;
}
```
# 09:编程填空：简单的对象
## 描述
程序填空，使得程序输出:
2
1
1
0
```
#include <iostream>
using namespace std;
class A
{
	static int num;
public:
	A(){num+=1;}
	void func()
	{
		cout<< num <<endl;
	}
// 在此处补充你的代码
};

int A::num=1;

int main()
{
	A a1;
	const A a2 = a1;
	A & a3 = a1;
	const A & a4 = a1;

	a1.func();
	a2.func();
	a3.func();
	a4.func();

	return 0;
}
```
## 输入
无
## 输出
2
1
1
0
## 样例输入
```
None
```
## 样例输出
```
2
1
1
0
```
# Solution
const变量在引用的时候需要引用静态成员函数，因此，我们只需重载func，并改变num即可
```
#include <iostream>
using namespace std;
class A
{
	static int num;
public:
	A(){num+=1;}
	void func()
	{
		cout<< num <<endl;
	}
	void func()const{
		num--;
		cout<<num<<endl;
	}
};

int A::num=1;

int main()
{
	A a1;
	const A a2 = a1;
	A & a3 = a1;
	const A & a4 = a1;

	a1.func();
	a2.func();
	a3.func();
	a4.func();

	return 0;
}
```

# 10:编程填空：a+b+c问题
## 描述
完善代码，使其能够按照指定方式输出
```
#include <iostream>
using namespace std;
// 在此处补充你的代码
int main() {
    int t;
    cin >> t;
    while (t --){
        int aa, bb, cc;
        cin >> aa >> bb >> cc;
        A a(aa);
        B b(bb);
        C c(cc);
        A* x = &a;
        A* y = &b;
        A* z = &c;
        cout << (x->get_value() + y->get_value() + z->get_value()) << " ";
        cout << ((*x) + y + z)->get_value() << endl;
    }
    return 0;
}
```
## 输入
第一行是数据组数t
每组数据1行，为三个整数 a 和 b 和 c
## 输出
对每组数据，输出 a+b+c，连续输出两次中间空格隔开。(数据保证结果在int范围内)

每组数据输出占一行
## 样例输入
3
1 2 3
1 2 4
6 6 6
## 样例输出
6 6
7 7
18 18

# Solution
这道题是真的掌握不熟...我们可以看到 用三个元素去重置a,b,c  
首先，明确B(int a):A(a)的含义？  
这个指的是因为B中的num是从A中继承过来的 所以调用的构造函数要是A中的 而不是多赋值  
然后(\*x)表示解指针 返回的是A类对象  
所以，我们要重载一个A+\A*的加号  
然后！就是->的重载  
我们为什么要重载A-> 因为加法返回的是一个A变量 我们需要把A先通过->转化为A*，再通过A*->来调用get_value()  
this 指的是返回当前对象的地址  
而 \*this 返回的是当前对象（A&）或者当前对象的拷贝A  
所以 要将A转化为A* 只要把->重载为this即可  
```
#include <iostream>
using namespace std;
class A{
public:
	int num;
	A():num(0){}
	A(int a){
		num=a;
	}
	int get_value(){
		return num;
	} 
	A* operator->(){
		return this;
	}
};
class B:public A{
public:
	B(int a):A(a){

	}	
};
class C:public A{
public:
	C(int a):A(a){

	}
};
A operator+(const A a,const A* b){
	A temp(a.num+b->num);
	return temp;
}
// 在此处补充你的代码
int main() {
    int t;
    cin >> t;
    while (t --){
        int aa, bb, cc;
        cin >> aa >> bb >> cc;
        A a(aa);
        B b(bb);
        C c(cc);
        A* x = &a;
        A* y = &b;
        A* z = &c;
        cout << (x->get_value() + y->get_value() + z->get_value()) << " ";
        cout << ((*x) + y + z)->get_value() << endl;
    }
    return 0;
}
```