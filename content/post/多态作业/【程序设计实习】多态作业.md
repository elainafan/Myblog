---
title: 多态作业
date: 2025-03-07
categories:
    - 程序设计实习
---
# A:看上去像多态
## 描述
程序填空产生指定输出
```
#include <iostream>
using namespace std;
class B { 
	private: 
		int nBVal; 
	public: 
		void Print() 
		{ cout << "nBVal="<< nBVal << endl; } 
		void Fun() 
		{cout << "B::Fun" << endl; } 
		B ( int n ) { nBVal = n;} 
};
// 在此处补充你的代码
int main() { 
	B * pb; D * pd; 
	D d(4); d.Fun(); 
	pb = new B(2); pd = new D(8); 
	pb -> Fun(); pd->Fun(); 
	pb->Print (); pd->Print (); 
	pb = & d; pb->Fun(); 
	pb->Print(); 
	return 0;
}
```
## 输入
无
## 输出
```
D::Fun
B::Fun
D::Fun
nBVal=2
nBVal=24
nDVal=8
B::Fun
nBVal=12
```
## 样例输入
无
## 样例输出
```
D::Fun
B::Fun
D::Fun
nBVal=2
nBVal=24
nDVal=8
B::Fun
nBVal=12
```
# Solution
题目给了我们一个很好的提示，“看起来是多态”，说明实际上不是多态  
不过，要注意 就算B作为基态指针指向的是派生类的对象d 但是因为没有虚函数所以还是调用B类函数  
下面看代码:
```
#include <iostream>
using namespace std;
class B { 
	private: 
		int nBVal; 
	public: 
		void Print() 
		{ cout << "nBVal="<< nBVal << endl; } 
		void Fun() 
		{cout << "B::Fun" << endl; } 
		B ( int n ) { nBVal = n;} 
};
class D:public B{
private:
	int nDVal;
public:
	D(int n):B(3*n){
		nDVal=n;
	}
	void Fun(){
		cout<<"D::Fun"<<endl;
	}
	void Print(){
		B::Print();
		cout<<"nDVal="<<nDVal<<endl;
	}
};
int main() { 
	B * pb; D * pd; 
	D d(4); d.Fun(); 
	pb = new B(2); pd = new D(8); 
	pb -> Fun(); pd->Fun(); 
	pb->Print (); pd->Print (); 
	pb = & d; pb->Fun(); 
	pb->Print(); 
	system("pause");
	return 0;
}
```

# B:Fun和Do
## 描述
程序填空输出指定结果
```
#include <iostream> 
using namespace std;
class A { 
	private: 
	int nVal; 
	public: 
	void Fun() 
	{ cout << "A::Fun" << endl; }; 
	void Do() 
	{ cout << "A::Do" << endl; } 
}; 
class B:public A { 
	public: 
	virtual void Do() 
	{ cout << "B::Do" << endl;} 
}; 
class C:public B { 
	public: 
	void Do( ) 
	{ cout <<"C::Do"<<endl; } 
	void Fun() 
	{ cout << "C::Fun" << endl; } 
}; 
void Call(
// 在此处补充你的代码
) { 
	p.Fun(); p.Do(); 
} 
int main() { 
	C c; 
	Call( c); 
	return 0;
}
```
## 输入
无
## 输出
```
A::Fun
C::Do
```
## 样例输入
```
None
```
## 样例输出
```
A::Fun 
C::Do 
```
# Solution
对于对象p 要执行p的fun和do操作  
看输出 由于B中没有派生的fun 所以它的fun从A继承 表明对象类型是B  
然后 因为派生的关系 主函数中的变量是C类型的  
而我们有虚函数的关系 由于C是B的派生类  
得知对于B的引用 可以导入C类型  
答案为B &p

# C:这是什么鬼delete
## 描述
程序填空输出指定结果
```
#include <iostream> 
using namespace std;
class A 
{ 
public:
	A() { }
// 在此处补充你的代码
}; 
class B:public A { 
	public: 
	~B() { cout << "destructor B" << endl; } 
}; 
int main() 
{ 
	A * pa; 
	pa = new B; 
	delete pa; 
	return 0;
}
```
## 输入
无
## 输出
```
destructor B
destructor A
```
## 样例输入
```
无
```
## 样例输出
```
destructor B
destructor A
```
# Solution
老师出这题的意义就是 对于虚析构函数，先执行派生类的析构函数，再执行基类的虚构函数，以析构干净
```
#include <iostream> 
using namespace std;
class A 
{ 
public:
	A() { }
	virtual ~A(){
		cout<<"destructor A"<<endl;
	}
}; 
class B:public A { 
	public: 
	~B() { cout << "destructor B" << endl; } 
}; 
int main() 
{ 
	A * pa; 
	pa = new B; 
	delete pa; 
	system("pause");
	return 0;
}
```

# D:怎么又是Fun和Do
## 描述
程序填空输出指定结果
```
#include <iostream>
using namespace std;
class A {
	private:
	int nVal;
	public:
	void Fun()
	{ cout << "A::Fun" << endl; };
	virtual void Do()
	{ cout << "A::Do" << endl; }
};
class B:public A {
	public:
	virtual void Do()
	{ cout << "B::Do" << endl;}
};
class C:public B {
	public:
	void Do( )
	{ cout <<"C::Do"<<endl; }
	void Fun()
	{ cout << "C::Fun" << endl; }
};
void Call(
// 在此处补充你的代码
) {
	p->Fun(); p->Do();
}
int main() {
	Call( new A());
	Call( new C());
	return 0;
}
```
## 输入
```
无
```
## 输出
```
A::Fun
A::Do
A::Fun
C::Do
```
## 样例输入
```
无
```
## 样例输出
```
A::Fun
A::Do
A::Fun
C::Do
```
# Solution
首先可以明确的是 括号里填的是指针  
然后填A的 完了（细想可知）  
看代码:
```
#include <iostream>
using namespace std;
class A {
	private:
	int nVal;
	public:
	void Fun()
	{ cout << "A::Fun" << endl; };
	virtual void Do()
	{ cout << "A::Do" << endl; }
};
class B:public A {
	public:
	virtual void Do()
	{ cout << "B::Do" << endl;}
};
class C:public B {
	public:
	void Do( )
	{ cout <<"C::Do"<<endl; }
	void Fun()
	{ cout << "C::Fun" << endl; }
};
void Call(A *p
) {
	p->Fun(); p->Do();
}
int main() {
	Call( new A());
	Call( new C());
	system("pause");
	return 0;
}
```