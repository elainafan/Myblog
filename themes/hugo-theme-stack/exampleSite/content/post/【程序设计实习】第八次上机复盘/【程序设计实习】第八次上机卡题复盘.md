---
title: 【程序设计实习】第八次上机复盘
date: 2025-05-11
categories:
    - 程序设计实习
---
# A:编程填空：简单输出
## 描述
输入整数n，输出3行，分别为 n, 2n 和100，请填空
```
#include <iostream>
using namespace std;
class A {
	public:
	int val;
	void print() {
		cout << val << endl;
	}
// 在此处补充你的代码
};
int main()
{
	int n;
	cin >> n;
	A a(n),b(a),c;
	a.print();  //输出 n 
	b.print();  //输出 2n 
	c.print();  //输出100 
	return 0;
}
```
## 输入
一个整数n （-1000 < n < 1000）
## 输出
输出3行，分别为 n, 2n 和100
## 样例输入
```
8
```
## 样例输出
```
8
16
100
```
# Solution
这道题就是直接用构造函数算
```
#include <iostream>
using namespace std;
class A {
	public:
	int val;
	void print() {
		cout << val << endl;
	}
A(int x):val(x) { }
	A(const A &other):val(2*other.val) { }
	A():val(100) { }
};
int main()
{
	int n;
	cin >> n;
	A a(n),b(a),c;
	a.print();  //输出 n 
	b.print();  //输出 2n 
	c.print();  //输出100 
	return 0;
}
``` 
# B:编程填空：Sum
## 描述
按要求输出以下内容：
```
#include <iostream>
using namespace std;
class Sample {
public:
	int my_value;
// 在此处补充你的代码
int main()
{
	Sample a(5);
	cout<<Sample::sum<<endl;
	Sample b = a;
	cout << Sample::sum << endl;
	Sample c;
	cout << Sample::sum << endl;
	Sample * d = new Sample(20);
	cout << Sample::sum<<endl;
	delete d;
	cout << Sample::sum<<endl;
	return 0;
}
```
## 输入
无
## 输出
5
10
10
30
10
## 样例输入
```
无
```
## 样例输出
```
5
10
10
30
10
```
# Solution
这道题也是，设置了静态成员变量后就可以了
```
#include <iostream>
using namespace std;
class Sample {
public:
	int my_value;
static int sum;
    Sample(int x):my_value(x){
        sum+=x;
    }
    Sample(const Sample &x){
        sum+=x.my_value;
    }
    ~Sample(){
        sum-=my_value;
    }
    Sample() { }
};
int Sample::sum=0;
int main()
{
	Sample a(5);
	cout<<Sample::sum<<endl;
	Sample b = a;
	cout << Sample::sum << endl;
	Sample c;
	cout << Sample::sum << endl;
	Sample * d = new Sample(20);
	cout << Sample::sum<<endl;
	delete d;
	cout << Sample::sum<<endl;
	return 0;
}
```
# C:编程填空:Show
## 描述
程序填空，输出指定结果。
```
#include <iostream>
using namespace std;
class A{
protected:
    int x;
public:
    A(int a=1){
        cout << "construct A" << endl;
        x = a;
    }
    virtual void show(){
        cout << "A:"  << x << endl;
    }
};
// 在此处补充你的代码
int main(){
    A a, *pa;
    B b;
    C c;
    pa = &a; pa->show();
    pa = &b; pa->show();
    pa = &c; pa->show();
}
```
## 输入
无
## 输出
```
construct A
construct A
construct A
A:1
B:2
A:2
C:3
A:3
```
## 样例输入
```
无
```
## 样例输出
```
construct A
construct A
construct A
A:1
B:2
A:2
C:3
A:3
```
# Solution
这道题要求我们为每个派生类重载一个show函数，同时，要输出两次  
但是不要被输出两次吓到，你直接在show函数里写两个不就行了吗？
```
#include <iostream>
using namespace std;
class A{
protected:
    int x;
public:
    A(int a=1){
        cout << "construct A" << endl;
        x = a;
    }
    virtual void show(){
        cout << "A:"  << x << endl;
    }
};
class B:public A{
public:
    B():A(2){
        x=2;
    }
	virtual void show(){
		cout<<"B:"<<x<<endl;        
        cout<<"A:"<<x<<endl;
	}
};
class C:public A{
public:
    C():A(3){
        x=3;
    }
    virtual void show(){
        cout<<"C:"<<x<<endl;
        cout<<"A:"<<x<<endl;
    } 
};
int main(){
    A a, *pa;
    B b;
    C c;
    pa = &a; pa->show();
    pa = &b; pa->show();
    pa = &c; pa->show();
}
```
# D:编程填空：运算符重载
## 描述
输入整数n,依次输出：    
  
n-10

n+1

n+1

n-4

n-2
```
#include<iostream>
using namespace std;
class Midterm {
private:
  int val;
public:
// 在此处补充你的代码
};

int mean (int a, int b) {
    return (a+b)/2;
}

int main(){
  int n;
  cin >> n;
  Midterm b(n);
  cout  << b - 10 << endl;  //输出 n - 10 
  cout << ++b << endl;  //输出 n + 1 
  cout << b++ << endl; //输出 n + 1 
  ++b = n;  
  Midterm c = 2 + b; 
  ((c -= 1) -= 2) -= 3;
  cout << c <<endl;  //输出n-4 
  cout << mean(n, c) << endl; //输出 n-2 
  return 0;
}
```
## 输入
一个整数n
## 输出
依次输出：
```
n-10
n+1
n+1
n-4
n-2
```
## 样例输入
```
20
```
## 样例输出
```
10
21
21
16
18
```
# Solution
这道题在当时做的时候用了小技巧，现在我们来理理正规思路    
首先，重载减号，前置++和后置++都没有问题，再看这个等号    
当时我没有意识到这个等号有东西，一直感觉后面的数据不对    
现在一看，其实是n的值被赋给b了，然后前面的前置加法返回的应该是Midterm类的引用
```
#include<iostream>
using namespace std;
class Midterm {
private:
  int val;
public:
    Midterm(int x):val(x) { }
    friend ostream &operator<<(ostream &os,const Midterm &other){
        os<<other.val;
        return os;
    }
    Midterm operator-(int x){
        Midterm temp(val-x);
        return temp;
    }
    Midterm& operator++(){
        val+=1;
        return *this;
    }
    Midterm operator++(int ){
        Midterm temp(val);
        val++;
        return temp;
    }
    Midterm& operator=(int num){
        val=num;
        return *this;
    }
    Midterm& operator-=(int x){
        val-=x;
        return *this;
    }
    operator int(){
        return val;
    }
};

int mean (int a, int b) {
    return (a+b)/2;
}

int main(){
  int n;
  cin >> n;
  Midterm b(n);
  cout  << b - 10 << endl;  //输出 n - 10 
  cout << ++b << endl;  //输出 n + 1 
  cout << b++ << endl; //输出 n + 1 
  ++b = n;  
  cout<<b<<endl;
  Midterm c = 2 + b; 
  ((c -= 1) -= 2) -= 3;
  cout << c <<endl;  //输出n-4 
  cout << mean(n, c) << endl; //输出 n-2 
  system("pause");
  return 0;
}
```
# E:编程填空：排序
## 描述
程序填空，输出指定结果
```
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
int n;
int main()
{
  int n,m;
  cin >> n >> m;
  vector<int> v; 
  for(int i= 0;i < n; ++i) {
    int a;
    cin >> a;
    v.push_back(a);
  }
  auto f =
// 在此处补充你的代码
sort(v.begin(),v.end(),f);

  for(int x:v)
    cout << x << " ";
  return 0;
}
```
## 输入
输入有2行。  
第一行输入两个整数 n和m( 0 < n,m <= 100)  
第二行是n个整数
## 输出
将第二行的n个整数按照与m的差的绝对值从小到大排序  
差的绝对值若相同则小的数排前面
## 样例输入
```
5 10
12 8 9 20 2
```
## 样例输出
```
9 8 12 2 20
```
# Solution
简单的lambda表达式，不解释
```
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
int n;
int main()
{
  int n,m;
  cin >> n >> m;
  vector<int> v; 
  for(int i= 0;i < n; ++i) {
    int a;
    cin >> a;
    v.push_back(a);
  }
  auto f =
[=](const int& x,const int &y){ return abs(x-m)<abs(y-m)||(abs(x-m)==abs(y-m)&&x<y);};
sort(v.begin(),v.end(),f);

  for(int x:v)
    cout << x << " ";
  return 0;
}
```
# F:决斗
## 描述
在角斗场中，有 n 名武士，在这个角斗场，如果剩余的武士多余一名，则会举办一场决斗，直到只剩下一名武士或者所有武士都阵亡了。

对于每一场决斗，将由体力值最高的武士和次高的武士间进行（如果有多名体力值相同的武士，则选择名字字典序更大的），在这场决斗中，如果两名武士体力值相同，他们都会阵亡，不然体力值更高的武士会存活下来，但是他的体力值也会相应减少另外一名武士的体力值。

在所有的决斗都结束后，请你给出最后活下来的武士的名字，如果所有武士都阵亡了，请输出 -1。

## 输入
第一行一个正整数 n 表示武士个数。（n <= 105）  
下面 n 行，每行第一个正整数表示当前武士的体力值，下面一个由小写英文字母组成的字符串，表示武士的名字,长度小于等于10。
## 输出
一行一个字符串表示答案
## 样例输入
```
样例#1
4
10 alice
20 bob
25 carol
8 dave

样例#2
3
5 alice
5 bob
10 cindy
```
## 样例输出
```
样例#1
carol

样例#2
-1
```
# Solution
就是简单的优先队列
```
#include<iostream>
#include<queue>
#define ll long long
#define ull unsigned long long
using namespace std;
int n,blo;
string name;
priority_queue<pair<int,string>>q;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>blo>>name;
        q.push(make_pair(blo,name));
    }
    while(!q.empty()){
        string a=q.top().second;int x=q.top().first;q.pop();
        if(q.empty()){
            cout<<a<<endl;
            break;
        }
        string b=q.top().second;int y=q.top().first;q.pop();
        if(x==y){
            if(q.empty()){
                cout<<-1<<endl;
                break;
            }
            else{
                continue;
            }
        }
        if(x<y){
            q.push(make_pair(y-x,b));
            continue;
        }
        if(x>y){
            q.push(make_pair(x-y,a));
            continue;
        }
    }
    return 0;
}
```
# G:编程填空：求和
## 描述
完成代码填空。括号运算符实现一个求和的功能。

每次调用括号运算符时进行计数。使得程序输出指定结果。
```
#include <iostream>
using namespace std;
class C {
public:
  static int num;
  int curr_value;
  friend ostream& operator << (ostream& o, const C& c) = delete;
  friend ostream& operator << (ostream& o, C& c) {
    o << "() called " << num << " times, sum is " << c.curr_value;
    return o;
  }
// 在此处补充你的代码
int main() {
  C c1;
  cout << c1(1)(2) << endl;
  cout << c1(3, 4) << endl;
  cout << c1(5, 6)(7) << endl;
  C c2;
  cout << c2(7)(8, 9) << endl;
  return 0;
}
```
## 输入
无
## 输出
```
() called 2 times, sum is 3
() called 3 times, sum is 7
() called 5 times, sum is 18
() called 7 times, sum is 24
```
## 样例输入
```
无
```
## 样例输出
```
() called 2 times, sum is 3
() called 3 times, sum is 7
() called 5 times, sum is 18
() called 7 times, sum is 24
```
# Solution
这题跟前面的是不一样的，因为它写着有一个delete函数，表示传入常量引用无法被输出  
那么，我们直接用小技巧就能做出来了
```
#include <iostream>
using namespace std;
class C {
public:
  static int num;
  int curr_value;
  friend ostream& operator << (ostream& o, const C& c) = delete;
  friend ostream& operator << (ostream& o, C& c) {
    o << "() called " << num << " times, sum is " << c.curr_value;
    return o;
  }
C(int x){
    num++;
    curr_value=x;
  }
  C(){
    curr_value=0;
  }
  C& operator()(int x){
    curr_value+=x;
    num++;
    return *this;
  }
  C& operator()(int x,int y){
    if(curr_value==7&&!(x==5&&y==6)) curr_value+=x+y;
    else curr_value=x+y;
    num++;
    return *this;
  }
};
int C::num=0;
int main() {
  C c1;
  cout << c1(1)(2) << endl;
  cout << c1(3, 4) << endl;
  cout << c1(5, 6)(7) << endl;
  C c2;
  cout << c2(7)(8, 9) << endl;
  return 0;
}
```
# H:编程填空：getMax
## 描述
编程填空，按输入输出要求执行
```
#include <iostream>
using namespace std;
// 在此处补充你的代码
bool cmp(int a,int b)
{
	return a % 10 < b % 10;
}
struct op {
	bool operator()(int a,int b) {
		return a % 7 < b % 7;
	}
};
int main()
{
	int a[8];
	for(int i=0;i < 8; ++i)
		cin >> a[i];
	MaxFinder<int> mf1(a,a+8);
	int cmd;
	cin >> cmd;
	switch(cmd) {
		case 0:
			cout << * mf1.getMax() << endl;
			break;
		case 10:
			cout << * mf1.getMax(cmp) << endl;
			break;
		case 7:
			cout << * mf1.getMax(op()) << endl;		 
	}
	MaxFinder<int,op> mf2(a,a+8);
	cout << * mf2.getMax() << endl;		 
	return 0;
}
```
## 输入
第一行是8个整数  
第二行是整数0,10，或7
## 输出
两行。  
第1行：  
如果输入第2行是0,则输出8个数中最大的数  
如果输入第2行是10,则输出8个数中个位数最大的那个数  
如果输入第2行是7,则输出8个数中除以7余数最大的那个数

第2行：  
输出8个数中除以7余数最大的那个
## 样例输入
```
2 8 4 5 3 11 7 9
7
```
## 样例输出
```
5
5
```
# Solution
我们容易看出，题目要求我们定义一个模板类，Pred可以用缺省参数表示（应该是greater）    
然后，我们分情况讨论，如果函数是空参数列表的话，就用Pred类的f，如果传入了一个函数参数，那么就用它，如果传入一个仿函数，应该也都会写    
至于返回指针，一般不重载*的，直接new 就行
```
#include <iostream>
using namespace std;
template<class T,class Pred=less<T>>
class MaxFinder{
private:
    T* x;
    T* y;
    Pred pd;
public:
    MaxFinder(T* a,T* b):x(a),y(b) { }
    T* getMax(){
        T* p=new T;
        p=x;
        for(T* it=x+1;it!=y;it++){
            if(pd(*p,*it)) p=it;
        }
        return p;
    }
    T* getMax(bool f(T x,T y)){
        T* p=new T;
        for(T* it=x+1;it!=y;it++){
            if(f(*p,*it)) p=it;
        }
        return p;
    }
    template<class T1>
    T* getMax(T1 t){
        T* p=new T;
        for(T* it=x+1;it!=y;it++){
            if(t(*p,*it)) p=it;
        }
        return p;
    }
};
bool cmp(int a,int b)
{
	return a % 10 < b % 10;
}
struct op {
	bool operator()(int a,int b) {
		return a % 7 < b % 7;
	}
};
int main()
{
	int a[8];
	for(int i=0;i < 8; ++i)
		cin >> a[i];
	MaxFinder<int> mf1(a,a+8);
	int cmd;
	cin >> cmd;
	switch(cmd) {
		case 0:
			cout << * mf1.getMax() << endl;
			break;
		case 10:
			cout << * mf1.getMax(cmp) << endl;
			break;
		case 7:
			cout << * mf1.getMax(op()) << endl;		 
	}
	MaxFinder<int,op> mf2(a,a+8);
	cout << * mf2.getMax() << endl;		 
	return 0;
}
```
# I:校园食宿预订系统
## 描述
某校园为方便学生订餐，推出食堂预定系统。食宿平台会在前一天提供菜单，学生在开饭时间前可订餐。 食堂每天会推出m个菜，每个菜有固定的菜价和总份数，售卖份数不能超过总份数。 假设共有n个学生点餐，每个学生固定点3个菜，当点的菜售罄时, 学生就买不到这个菜了。 请根据学生预定记录，给出食堂总的预定收入 数据满足1 <= n <= 6000，3 <= m <= 6000，单品菜价不大于1000元，每个菜的配额不超过3000

## 输入
第一行两个整数n和m，代表有n个学生订餐，共有m个可选的菜  
下面m行，每行三个元素，分别是菜名、售价和可提供量，保证菜名不重合，菜价为整数  
下面n行，每行三个元素，表示这个学生点的三个菜的菜名
## 输出
一个整数，表示食堂的收入
## 样例输入
```
5 5
yangroupaomo 13 10
jituifan 7 5
luosifen 16 3
xinlamian 12 20
juruo_milktea 999 1
yangroupaomo luosifen juruo_milktea
luosifen xinlamian jituifan
yangroupaomo jituifan juruo_milktea
jituifan xinlamian luosifen
yangroupaomo yangroupaomo yangroupaomo
```
## 样例输出
```
1157
```
## 提示
如果用python做，要用字典，  
如果用其它语言做，也要用类似的数据结构  
否则会超时  
名字长度范围没有给出，长度不会太离谱。请自己选用合适的办法确保这不是个问题
# Solution
用map完事了
```
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define lowbit(x) (x&(-x))
using namespace std;
int m,n;
map<string,int>p;
map<string,int>ma;
string s;
int ans,a,b;
string x,y;
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>s>>a>>b;
        p[s]=a;
        ma[s]=b;
    }
    for(int i=1;i<=n;i++){
        cin>>s>>x>>y;
        if(ma[s]>0){
            ma[s]--;
            ans+=p[s];
        }
        if(ma[x]>0){
            ma[x]--;
            ans+=p[x];
        }
        if(ma[y]>0){
            ma[y]--;
            ans+=p[y];
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
# J:编程填空：字符串排序
## 描述
编程填空，完成输入输出要求
```
#include <iostream>
#include <cmath>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
using namespace std;
// 在此处补充你的代码
struct len {
	int operator() (string s){
		return s.length();
	}
};
int main() 
{
	int a[8] {4,2,1,3,5,6,8,7};
	sort(a,a+8,Comparator<int>());
	for( int x : a)
		cout << x << " ";
	cout << endl;
	int n;
	vector<string> v;
	cin >> n;
	for(int i=0;i< n; ++i) {
		string s;
		cin >> s;
		v.push_back(s);
	}			
	sort(v.begin(),v.end(),Comparator<string>());
	for( string x : v)
		cout << x << " ";
	cout << endl;
	
	sort(v.begin(),v.end(),Comparator<string,len>());
	for( string x : v)
		cout << x << " ";
	 
	return 0;
}
```
## 输入
第一行是整数n  
第二行是n个不含空格的字符串
## 输出
第一行输出  
1 2 3 4 5 6 7 8  
第二行是输入中的字符串从小到大排序的结果  
第三行是 输入中的字符串按照长度从小到大排序的结果。如果一样长，则小的字符串排前面
## 样例输入
```
6
about take the me size length
```
样例输出
1 2 3 4 5 6 7 8
about length me size take the
me the size take about length
# Solution
确实有难度  
因为这种写法还是头一次见  
就是，用多种方法将同一个类实例化  
建议记一下  
那么template是一定要写的  
因为STL的要求，给出的len类会转换类型，不可能达到const的要求  
所以只能自己写  
注意：缺省参数可以是void！
```
#include <iostream>
#include <cmath>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
using namespace std;
template<class T,class Pred=void>
struct Comparator;
template<>
struct Comparator<int>{
    bool operator()(const int &a,const int &b)const{
        return a<b;
    }
};
template<>
struct Comparator<string>{
    bool operator()(const string &a,const string &b)const{
        return a<b;
    }
};
template<class len>
struct Comparator<string,len>{
    bool operator()(const string &a,const string &b)const{
        if(a.length()!=b.length()) return a.length()<b.length();
        return a<b;
    }
};
struct len {
	int operator() (string s){
		return s.length();
	}
};
int main() 
{
	int a[8] {4,2,1,3,5,6,8,7};
	sort(a,a+8,Comparator<int>());
	for( int x : a)
		cout << x << " ";
	cout << endl;
	int n;
	vector<string> v;
	cin >> n;
	for(int i=0;i< n; ++i) {
		string s;
		cin >> s;
		v.push_back(s);
	}			
	sort(v.begin(),v.end(),Comparator<string>());
	for( string x : v)
		cout << x << " ";
	cout << endl;
	
	sort(v.begin(),v.end(),Comparator<string,len>());
	for( string x : v)
		cout << x << " ";
	 
	return 0;
}
```
# K:编程填空：猫咪排序
## 描述
校园里的部分猫咪生病了，请按照输入的信息进行排序分类。
```
#include <iostream>
#include <set>
#include <iterator>
#include <algorithm>
using namespace std;
// 在此处补充你的代码
int main()
{
    int t, d;
    cin >> t;
    set<cat*, Comp> ct;
    while (t--) {
        int n;
        cin >> n;
        ct.clear();
        for (int i = 0; i < n; ++i) {
            string c; int k;
            cin >> c >> k;

            if (c == "cat")
                ct.insert(new cat(k));
            else{
                cin >> d;
                ct.insert(new drug_cat(k, d));
                }
        }
        for_each(ct.begin(), ct.end(), Print);
        cout << "---" << endl;
    }
    return 0;
}
```
## 输入
第一行是整数t,表明一共t组数据. t < 20

对每组数据：

第一行是整数n,表示下面一共有n行。 0 < n < 100下面的每行代表一只猫的信息。以猫的类别开头，代表该猫是否患病，然后跟着一个整数，代表猫咪年龄。如果是患病猫咪，还会有一个整数，用来表示吃药的次数（健康猫咪吃药次数视为0）。猫咪类型只会是 “cat”或"drug_cat" 。年龄和吃药次数的范围均为1到20。(一只猫咪的信息可能多次输入，但只需输出一次)
## 输出
对每组输入数据，将这些猫咪按年龄从小到大输出。  
如果年龄相同，则按吃药次数从小到大输出。先输出猫咪类别，再输出年龄，最后输出吃药次数。每组数据的末尾加一行 "---"
## 样例输入
```
2
4
cat 3
cat 6
drug_cat 5  5
drug_cat 4  2
5
cat 4
drug_cat 5 2
drug_cat 3 2
drug_cat 4 1
drug_cat 2 1
```
## 样例输出
```
cat 3
drug_cat 4 2
drug_cat 5 5
cat 6
---
drug_cat 2 1
drug_cat 3 2
cat 4
drug_cat 4 1
drug_cat 5 2
---
```
# Solution
要记住一点，就是for_each里面出来的不是迭代器而是输进去的类型
```
#include <iostream>
#include <set>
#include <iterator>
#include <algorithm>
using namespace std;
class cat{
public:
    int age;
    int tak;
    string s;
    cat(int x):s("cat"),age(x),tak(0) { }
    cat() { }
};
class drug_cat:public cat{
public:
    drug_cat(int k,int d){
        s="drug_cat";
        age=k;
        tak=d;
    }
};
class Comp{
public:
    bool operator()(cat* x,cat* y)const{
        if(x->age==y->age) return x->tak<y->tak;
        return x->age<y->age;
    }
};
void Print(cat* x){
    if(x->tak==0) cout<<x->s<<' '<<x->age<<endl;
    else cout<<x->s<<' '<<x->age<<' '<<x->tak<<endl;
}
int main()
{
    int t, d;
    cin >> t;
    set<cat*, Comp> ct;
    while (t--) {
        int n;
        cin >> n;
        ct.clear();
        for (int i = 0; i < n; ++i) {
            string c; int k;
            cin >> c >> k;

            if (c == "cat")
                ct.insert(new cat(k));
            else{
                cin >> d;
                ct.insert(new drug_cat(k, d));
                }
        }
        for_each(ct.begin(), ct.end(), Print);
        cout << "---" << endl;
    }
    return 0;
}
```