---
title: 运算符重载作业
date: 2025-02-26
categories:
    - 程序设计实习
---
# A:MyString
## 描述
补足MyString类，使程序输出指定结果
```
#include <iostream>
#include <string>
#include <cstring>
using namespace std;
class MyString {
	char * p;
public:
	MyString(const char * s) {
		if( s) {
			p = new char[strlen(s) + 1];
			strcpy(p,s);
		}
		else
			p = NULL;

	}
	~MyString() { if(p) delete [] p; }
// 在此处补充你的代码
};
int main()
{
	char w1[200],w2[100];
	while( cin >> w1 >> w2) {
		MyString s1(w1),s2 = s1;
		MyString s3(NULL);
		s3.Copy(w1);
		cout << s1 << "," << s2 << "," << s3 << endl;

		s2 = w2;
		s3 = s2;
		s1 = s3;
		cout << s1 << "," << s2 << "," << s3 << endl;
		
	}
}
```
## 输入
多组数据，每组一行，是两个不带空格的字符串
## 输出
对每组数据，先输出一行，打印输入中的第一个字符串三次  
然后再输出一行，打印输入中的第二个字符串三次
## 样例输入
```
abc def
123 456
```
## 样例输出
```
abc,abc,abc
def,def,def
123,123,123
456,456,456
```
## Solution
可以看到的是 题目已经帮我们写好了一个复制构造函数和一个析构函数，我们还需要再写一个复制构造函数  
同时，要重载=运算符，copy函数，以及重载输出运算符  
代码放下面:
```
#include <iostream>
#include <string>
#include <cstring>
using namespace std;
class MyString {
	char * p;
public:
	MyString(const char * s) {
		if( s) {
			p = new char[strlen(s) + 1];
			strcpy(p,s);
		}
		else
			p = NULL;
	}
	~MyString() { if(p) delete [] p; }
    MyString(const MyString &s){
        if(s.p){
            p=new char[strlen(s.p)+1];
            strcpy(p,s.p);
        }
        else{
            p=NULL;
        }
    }
    MyString &operator=(const MyString &s){
        if(s.p){
            if(p) delete[] p;
            p=new char[strlen(s.p)+1];
            strcpy(p,s.p);
        }
        else{
            p=NULL;
        }
        return *this;//这行老忘写
    }
    void Copy(const MyString &s){
        if(p) delete[] p;
        if(s.p){
            p=new char[strlen(s.p)+1];
            strcpy(p,s.p);
        }
        else{
            p=NULL;
        }
    }
    friend ostream &operator<<(ostream &os,MyString &s){
        if(s.p){
            os<<s.p;
        }
        return os;
    }
};
int main()
{
	char w1[200],w2[100];
	while( cin >> w1 >> w2) {
		MyString s1(w1),s2 = s1;
		MyString s3(NULL);
		s3.Copy(w1);
		cout << s1 << "," << s2 << "," << s3 << endl;

		s2 = w2;
		s3 = s2;
		s1 = s3;
		cout << s1 << "," << s2 << "," << s3 << endl;
		
	}
}
```
# B:看上去好坑的运算符重载
## 描述
```
#include <iostream> 
using namespace std;
class MyInt 
{ 
	int nVal; 
	public: 
	MyInt( int n) { nVal = n ;}
// 在此处补充你的代码
}; 
int Inc(int n) {
	return n + 1;
}
int main () { 
	int n;
	while(cin >>n) {
		MyInt objInt(n); 
		objInt-2-1-3; 
		cout << Inc(objInt);
		cout <<","; 
		objInt-2-1; 
		cout << Inc(objInt) << endl;
	}
	return 0;
}
```
## 输入
多组数据，每组一行，整数n
## 输出
对每组数据，输出一行，包括两个整数， n-5和n - 8
## 样例输入
```
20
30
```
## 样例输出
```
15,12
25,22
```
## Solution
我们要重载一个减号和类型转换函数 简单不讲
```
#include <iostream> 
using namespace std;
class MyInt 
{ 
	int nVal; 
	public: 
	MyInt( int n) { nVal = n ;}
    MyInt &operator-(int x){
        nVal=nVal-x;
        return *this;
    }
    operator int(){
        return nVal;
    }
// 在此处补充你的代码
}; 
int Inc(int n) {
	return n + 1;
}
int main () { 
	int n;
	while(cin >>n) {
		MyInt objInt(n); 
		objInt-2-1-3; 
		cout << Inc(objInt);
		cout <<","; 
		objInt-2-1; 
		cout << Inc(objInt) << endl;
	}
	return 0;
}
```
# C:惊呆！Point竟然能这样输入输出
## 描述
```
#include <iostream> 
using namespace std;
class Point { 
	private: 
		int x; 
		int y; 
	public: 
		Point() { };
// 在此处补充你的代码
}; 
int main() 
{ 
 	Point p;
 	while(cin >> p) {
 		cout << p << endl;
	 }
	return 0;
}
```
## 输入
多组数据，每组两个整数
## 输出
对每组数据，输出一行，就是输入的两个整数
## 样例输入
```
2 3
4 5
```
## 样例输出
```
2,3
4,5
```
# Solution 
需要我们重载输入函数和输出函数，简单不讲
```
#include <iostream> 
using namespace std;
class Point { 
	private: 
		int x; 
		int y; 
	public: 
		Point() { };
        friend istream &operator>>(istream &is,Point &p) {
            is>>p.x>>p.y;
            return is;
        }//输入不能有const
        friend ostream &operator<<(ostream &os,const Point &p){
            os<<p.x<<','<<p.y;
            return os;
        }
// 在此处补充你的代码
}; 
int main() 
{ 
 	Point p;
 	while(cin >> p) {
 		cout << p << endl;
	 }
	return 0;
}
```
# D:二维数组类
## 描述
写一个二维数组类 Array2,使得下面程序的输出结果是：

0,1,2,3,

4,5,6,7,

8,9,10,11,

next

0,1,2,3,

4,5,6,7,

8,9,10,11,

程序：
```
#include <iostream>
#include <cstring>
using namespace std;

class Array2 {
// 在此处补充你的代码
};

int main() {
    Array2 a(3,4);
    int i,j;
    for(  i = 0;i < 3; ++i )
        for(  j = 0; j < 4; j ++ )
            a[i][j] = i * 4 + j;
    for(  i = 0;i < 3; ++i ) {
        for(  j = 0; j < 4; j ++ ) {
            cout << a(i,j) << ",";
        }
        cout << endl;
    }
    cout << "next" << endl;
    Array2 b;     b = a;
    for(  i = 0;i < 3; ++i ) {
        for(  j = 0; j < 4; j ++ ) {
            cout << b[i][j] << ",";
        }
        cout << endl;
    }
    return 0;
}
```
## 输入
无
## 输出
```
0,1,2,3,
4,5,6,7,
8,9,10,11,
next
0,1,2,3,
4,5,6,7,
8,9,10,11,
```
## 样例输入
```
None
```
## 样例输出
```
0,1,2,3,
4,5,6,7,
8,9,10,11,
next
0,1,2,3,
4,5,6,7,
8,9,10,11,
```
# Solution
这题是重头戏！看了有点久都没看懂  
我来讲讲具体理论吧 首先要定义一个x,y为行宽行高，然后介绍二重指针$\*\*p$   
它指向的对象仍为指针  
看下面代码 
在构造函数中 我们写了一行 p=new int*[x]  
这是什么意思呢？  
也就是说 为指针p分配了x片空间  
然后看下面 p[i]表示p偏移了i个空间  
因为分配的空间都是连续的  
然后看重载的运算[]  
指的就是返回从p的位置开始，偏移了几个变量，返回值仍是指针  
p[a][b]是在p[a]返回一个int*的变量后，再偏移了b个单位  
最后的=重载就没啥事了  
- ### 注：此题写于笔者初学面向对象之时，也可用int*做（类似后面的三维数组类实现）  

看代码:
```
#include <iostream>
#include <cstring>
using namespace std;

class Array2 {
private:
    int x,y;//y才是行宽
    int **p;//指针要注意
public:
    Array2(){}
    Array2(int a,int b){
        x=a;y=b;
        if(a>0&&b>0){
            p=new int*[x];
            for(int i=0;i<y;i++){
                p[i]=new int[y];
            }
        }
        else{
            p=NULL;
        }
    }
    int* operator[](int t){
        return p[t];//从p的位置开始，偏移了多少个变量
    }
    int &operator()(int a,int b){
        return p[a][b];
    }
    Array2 &operator=(const Array2 &b){
        x=b.x;
        y=b.y;
        if(x>0&&y>0){
            p=new int*[x];
            for(int i=0;i<x;i++){
                p[i]=new int[y];
                for(int j=0;j<=y;j++){
                    p[i][j]=b.p[i][j];
                }
            }
        }
        else{
            p=NULL;
        }
        return *this;
    }
// 在此处补充你的代码
};

int main() {
    Array2 a(3,4);
    int i,j;
    for(  i = 0;i < 3; ++i )
        for(  j = 0; j < 4; j ++ )
            a[i][j] = i * 4 + j;
    for(  i = 0;i < 3; ++i ) {
        for(  j = 0; j < 4; j ++ ) {
            cout << a(i,j) << ",";
        }
        cout << endl;
    }
    cout << "next" << endl;
    Array2 b;     b = a;
    for(  i = 0;i < 3; ++i ) {
        for(  j = 0; j < 4; j ++ ) {
            cout << b[i][j] << ",";
        }
        cout << endl;
    }
    system("pause");
    return 0;
}
```
# E:别叫，这个大整数已经很简化了!
## 描述
程序填空，输出指定结果
```
#include <iostream> 
#include <cstring> 
#include <cstdlib> 
#include <cstdio> 
using namespace std;
const int MAX = 110; 
class CHugeInt {
// 在此处补充你的代码
};
int  main() 
{ 
	char s[210];
	int n;

	while (cin >> s >> n) {
		CHugeInt a(s);
		CHugeInt b(n);

		cout << a + b << endl;
		cout << n + a << endl;
		cout << a + n << endl;
		b += n;
		cout  << ++ b << endl;
		cout << b++ << endl;
		cout << b << endl;
	}
	return 0;
}
```
## 输入
多组数据，每组数据是两个非负整数s和 n。s最多可能200位， n用int能表示
## 输出
对每组数据，输出6行，内容对应程序中6个输出语句
## 样例输入
```
99999999999999999999999999888888888888888812345678901234567789 12
6 6
```
## 样例输出
```
99999999999999999999999999888888888888888812345678901234567801
99999999999999999999999999888888888888888812345678901234567801
99999999999999999999999999888888888888888812345678901234567801
25
25
26
12
12
12
13
13
14
```
# Solution
这题其实思维难度并不大   
我们认清有三个构造函数 然后重载几个加号，最后重载一下输出即可  
```
#include <iostream> 
#include <cstring> 
#include <cstdlib> 
#include <cstdio> 
using namespace std;
const int MAX = 110; 
class CHugeInt {
private:
    int c[210];
    int len;
public:
    CHugeInt(){
        len=0;
        memset(c,0,sizeof(c));
    }
    CHugeInt(char s[]){  
        memset(c,0,sizeof(c));
        int l=strlen(s);
        for(int i=0;i<=l-1;i++){
            c[i]=s[i]-'0';
        }
        len=l;
        int i=0,j=len-1;
        while(i<j){
            swap(c[i],c[j]);
            i++;j--;
        }
    }
    CHugeInt(int n){
        memset(c,0,sizeof(c));
        int tem=n;
        len=0;
        while(tem>0){
            c[len++]=tem%10;
            tem/=10;
        }
    }
    CHugeInt operator+(const CHugeInt &s){
        CHugeInt temp;
        temp.len=max(len,s.len);
        for(int i=0;i<=temp.len-1;i++){
            temp.c[i]=c[i]+s.c[i];
        }
        for(int i=0;i<=temp.len-1;i++){
            if(temp.c[i]/10){
                temp.c[i+1]+=temp.c[i]/10;
                temp.c[i]%=10;
            }
        }
        if(temp.c[temp.len]) temp.len++;
        return temp;
    }
    CHugeInt &operator+(const int n){
        CHugeInt temp(n);
        *this=this->operator+(temp);
        return *this;
    }
    CHugeInt &operator+=(int n){
        CHugeInt temp(n);
        *this=this->operator+(temp);
        return *this;
    }
    CHugeInt &operator++(){
        CHugeInt temp(1);
        *this=this->operator+(temp);
        return *this;
    }
    CHugeInt operator++(int ){
        CHugeInt temp;
        for(int i=0;i<=len-1;i++){
            temp.c[i]=c[i];
        }
        temp.len=len;
        *this=this->operator+(1);
        return temp;
    }
    friend CHugeInt operator+(int n,CHugeInt s){
        CHugeInt temp(n);
        s=s+temp;
        return s;        
    }
    friend ostream &operator<<(ostream &os,const CHugeInt &s){
        for(int i=s.len-1;i>=0;i--){
            os<<s.c[i];
        }
        return os;
    }
};
int  main() 
{ 
	char s[210];
	int n;

	while (cin >> s >> n) {
		CHugeInt a(s);
		CHugeInt b(n);

		cout << a + b << endl;
		cout << n + a << endl;
		cout << a + n << endl;
		b += n;
		cout  << ++ b << endl;
		cout << b++ << endl;
		cout << b << endl;
	}
	return 0;
}
```