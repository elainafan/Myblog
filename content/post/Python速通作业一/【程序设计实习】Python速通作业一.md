---
title: Python速通作业一
date: 2025-03-12
categories:
    - 程序设计实习
---
# A 反向输出一个三位数
## 描述
将一个三位数反向输出。
## 输入
一个三位数n。
## 输出
反向输出n。
## 样例输入
```
100
```
## 样例输出
```
001
```
# Solution
模拟即可
```py
s=input()
reverse_s=s[::-1]
print(reverse_s)
```

# B:字符串中的整数求和
## 描述
输入两个长度为3的字符串，每个串前两个字符是数字,后一个字符是字母。   
求这两个串中的整数的和
## 输入
一行，两个字符串
## 输出
两个字符串中整数的和
## 样例输入
```
12B 34D
```
## 样例输出
```
46
```
# Solution
提取列表 再提取数字  
加号的意思是先将字符串拼接 再转化成整数类
```py
lst=input().split()
x=int(lst[0][0]+lst[0][1])
y=int(lst[1][0]+lst[1][1])
print(x+y)
```

# C:点与正方形的关系
## 描述
有一个正方形，四个角的坐标（x,y)分别是（1，-1），（1，1），（-1，-1），（-1，1），x是横轴，y是纵轴。  
写一个程序，判断一个给定的点是否在这个正方形内（包括正方形边界）。
## 输入
输入一行，包括两个整数x、y，以一个空格分开，表示坐标(x,y)。
## 输出
输出一行，如果点在正方形内，则输出yes，否则输出no。
## 样例输入
```
1 1
```
## 样例输出
```
yes
```
# Solution
根据题意实现即可
```py
lst=input().split()
x=int(lst[0])
y=int(lst[1])
if -1<=x<=1 and -1<=y<=1:
    print("yes")
else:
    print("no")
```

# D:简单计算器
## 描述
一个最简单的计算器，支持+, -, *, / 四种运算。仅需考虑输入输出为整数的情况(除法结果就是商，忽略余数）
## 输入
输入只有一行，共有三个参数，其中第1、2个参数为整数，第3个参数为操作符（+,-,*,/）。
## 输出
输出只有一行，一个整数，为运算结果。然而：
1. 如果出现除数为0的情况，则输出：Divided by zero!
2. 如果出现无效的操作符(即不为 +, -, *, / 之一），则输出：Invalid operator!
## 样例输入
```
1 2 +
```
## 样例输出
```
3
```
# Solution
根据题意实现即可
```py
lst=input().split()
x=int(lst[0])
y=int(lst[1])
z=lst[2]
if z=="+":
    print(x+y)
elif z=='-':
    print(x-y)
elif z=='*':
    print(x*y)
elif z=='/' and y!=0:
    print(x//y)
elif z=='/' and y==0:
    print("Divided by zero!")
else:
    print("Invalid operator!")
```

# E:围栏
## 描述
小 A 打算新建一幢楼，这幢楼需要占用一块长方形的面积恰好为 n 平方米的土地，且为了方便测量，这块土地的长宽必须为整数米。  
小 A 需要在这幢楼外边修围栏，围栏长度为这块长方形的周长。  
现在想要知道最小的围栏长度。
## 输入
第一行一个正整数 n(n ≤ 2 × 109)，表示楼的面积。
## 输出
一行一个数表示答案。数据保证答案在int范围内。
## 样例输入
```
2
```
## 样例输出
```
6
```
# Solution
根据题意枚举即可
```py
import math
s=int(input())
mi=float("inf")
for i in range(1,int(math.sqrt(s))+1):
    if s%i==0:
        l=s//i
        c=2*(l+i)
        mi=min(c,mi)
print(mi)
```

# F:解密
## 描述
有一种简单的加密算法，对于一个长度为n的字符串，这个算法将会以第(n+1)/2（向下取整）个字符为中间轴(最左边的字符算第1个字符），将该字符写在密文的开头，然后对左半部分按照同样的办法进行加密并写下密文，再对右半部分按照同样的办法进行加密并写下密文。以此类推，直到左右部分为空，即完成加密。  
例如，如果要对12345678进行加密，第一步将选择4作为中间轴，将其写在密文开头，然后继续对左右两边（123和5678）分别继续按这个算法处理并写下，我们可以将其记作4[123][5678]（[]代表待加密处理的部分）。  
对于左半部分123，中间轴是2，左半部分为1，右半部分为3因此加密结果为213（1的中间轴为1，左右均为空，因此结果为1，而3同理）。  
对于右半部分5678，中间轴是6，左半部分为5，右半部分为78，因此加密结果为65[78] → 6578（78的中间轴为7，左半部分为空，右半部分为8，因此得到78）。  
简单来说，整个加密过程如下：  
12345678 → 4[123][5678] → 42[1][3][5678]→ 4213[5678] → 42136[5][78] → 42136578  
因此，对12345678的加密结果为42136578。  
现在给出一个长度为n(1 ≤ n ≤  50000)的由数字构成的字符串，这个字符串是加密后的密文，请你还原出加密前的明文。
## 输入
一行，一个长度为n(1 ≤ n ≤ 50000)的由数字构成的字符串字符串，代表加密后的密文。
## 输出
一行，一个长度同样为n的字符串，代表解密后的明文。
## 样例输入
```
123456789
```
## 样例输出
```
324517689
```
## 提示
324517689 → 1[3245][7689] → 12[3][45][7689] → 12345[7689] → 123456[7][89] → 123456789
# Solution
看到题目发现是用递归去做 然后二分指针  
然而在python里面我们不会递归(笔者注：当时老师还没讲)  
然后就查了一下资料：  
注意，列表在函数里是可变对象，而其他不是！（笔者注：函数中可变对象是可变的，而不可变对象只传值）
```py
def operate(s):
    n=len(s)
    res=['']*n
    index=[0] #采用列表，这样作为可变对象可以传递到外部
    def lower_bound(l,r):
        if l>r:
            return 
        mid=(l+r)//2
        res[mid]=s[index[0]]
        index[0]+=1
        lower_bound(l,mid-1)
        lower_bound(mid+1,r)
    lower_bound(0,n-1)
    return ''.join(res)
u=input()
print(operate(u))
```