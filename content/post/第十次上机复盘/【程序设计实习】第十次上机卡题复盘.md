---
title: 第十次上机复盘
date: 2025-06-08
categories:
    - 程序设计实习
---
# 04:特殊日历计算
## 描述
有一种特殊的日历法，它的一天和我们现在用的日历法的一天是一样长的。它每天有10个小时，每个小时有100分钟，每分钟有100秒。10天算一周，10周算一个月，10个月算一年。现在要你编写一个程序，将我们常用的日历法的日期转换成这种特殊的日历表示法。这种日历法的时、分、秒是从0开始计数的。日、月从1开始计数，年从0开始计数。秒数为整数。假设 0:0:0 1.1.2000 等同于特殊日历法的 0:0:0 1.1.0。
## 输入
第一行是一个正整数 N ,表明下面有 N 组输入。每组输入有一行，格式如下：hour:minute:second day.month.year  
表示常规的日期。日期总是合法的。2000 <= year <= 50000。
## 输出
每组输入要求输出一行。格式如下：mhour:mmin:msec mday.mmonth.myear 是输入日期的特殊日历表示方法。
## 样例输入
```
7
0:0:0 1.1.2000
10:10:10 1.3.2001
0:12:13 1.3.2400
23:59:59 31.12.2001
0:0:1 20.7.7478
0:20:20 21.7.7478
15:54:44 2.10.20749
```
## 样例输出
```
0:0:0 1.1.0
4:23:72 26.5.0
0:8:48 58.2.146
9:99:98 31.8.0
0:0:1 100.10.2000
0:14:12 1.1.2001
6:63:0 7.3.6848
```
# Solution
这道题其实上机的时候题目没看懂，花了很多时间，但是看懂了也需要调很久  
这就是为什么我不喜欢做日历题的原因，太坑了  
我们这道题可以将日期和时间分成两个层次看待，这样更方便我们debug，同时好像就应该这么做  
注意：对于天数我们要适当举特例来找出需要特判的情况来debug
```py
def pd(x):
    if x%4==0 and x%100!=0:
        return True
    if x%400==0:
        return True
    return False

n=int(input())
rc=[0,31,29,31,30,31,30,31,31,30,31,30,31,30]
c=[0,31,28,31,30,31,30,31,31,30,31,30,31,30]
for i in range(1,n+1):
    lst=input().split()
    m=lst[0].split(':')
    l=lst[1].split('.')
    d=0
    d+=int(l[0])-1
    y=int(l[2])
    if pd(y):
        for j in range(1,int(l[1])):
            d+=rc[j]
    else:
        for j in range(1,int(l[1])):
            d+=c[j]
    tem=0
    tem+=(y-2001)//4+(y-2001)//400-(y-2001)//100+1
    if y==2000:
        tem=0
    d+=(y-2000-tem)*365+tem*366
    if d%1000==0:
        year=d//1000
        month=1 
        day=1
    else:
        year=d//1000
        if (d%1000)%100==0:
            month=(d%1000)//100+1
            day=1
        else:
            month=(d%1000)//100+1
            day=d%100+1
    temp=0
    temp+=int(m[0])*3600
    temp+=int(m[1])*60
    temp+=int(m[2])
    te=temp*100000//86400
    hour=te//10000
    minute=(te%10000)//100
    second=te%100
    print(f"{hour}:{minute}:{second} {day}.{month}.{year}")
```
# 05:相关月
## 描述
“相关月”是指那些在一年中月份的第一天星期数相同的月份。例如，九月和十二月是相关的，因为九月一日和十二月一日的星期数总是相同的。两个月份相关，当且仅当两个月份第一天相差的天数能被7整除，也就是说，这两天相差为几个整星期。又如，二月和三月一般都是相关月，因为二月有28天，能被7整除，也恰好为4个星期。而在闰年，一月和二月的相关月与它们在平年的相关月是不同的，因为二月有29天，其后每个月份的第一天星期数都推后了一天。

## 输入
输入的第一行为整数n（n ≤ 200），
其后n行，每行三个整数，依次为一个年份和两个月份，整数之间用一个空格分隔。
输出
输出有n行，对应于每个输入的年份和相应两个月份，
如果这两个月份是相关的，则输出YES；  
否则，输出NO。
## 样例输入
```
5
1994 10 9
1935 12 1
1957 1 9
1917 9 12
1948 1 4
```
## 样例输出
```
NO
NO
NO
YES
YES
```
# Solution
考场傻了，竟然跑去打表  
为啥要打表？直接算不行吗（）
```py
def pd(x):
    if x%4==0 and x%100!=0:
        return True
    elif x%400==0:
        return True
    return False
n=int(input())
for i in range(1,n+1):
    lst=input().split()
    y=int(lst[0])
    m1=int(lst[1])
    m2=int(lst[2])
    if m2<m1:
        tem=m2
        m2=m1
        m1=tem
    if pd(y):
        if m1==1:
            if m2==4 or m2==7:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==2:
            if m2==8:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==3:
            if m2==11:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==4:
            if m2==7:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==9:
            if m2==12:
                print("YES")
            else:
                print("NO")
            continue
        else:
            print("NO")
    else:
        if m1==1:
            if m2==10:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==2:
            if m2==11 or m2==3:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==3:
            if m2==11:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==4:
            if m2==7:
                print("YES")
            else:
                print("NO")
            continue
        elif m1==9:
            if m2==12:
                print("YES")
            else:
                print("NO")
            continue
        else:
            print("NO")
```
# 06:更强的卷王查询系统
## 描述
古人云：“开卷有益”。但是，著名的社会学家小明认为内卷是有害的，并且他正在写一篇与P大内卷现状有关的论文，需要选取具有代表性的“卷王”们进行访谈。小明现在搞到了一份长长的成绩单，拜托你写个程序，帮他找出成绩单上的“卷王”们。

“卷王”的定义是：给定一组课程，这组课程全部上过的学生中，这组课程平均分最高的学生。小明已经通过复杂的数据挖掘手段得到了要分析的课程组，现在需要你按照上述定义，对每组课程找出那个真正的“卷王”。

## 输入
第1行：一个整数n， 1 <= n <= 100000

第2~(n+1)行：每行有用空格分隔的两个字符串和一个整数，前两个字符串分别代表课程名和学生名，最后一个整数代表这个学生在此课程中取得的成绩。输入保证课程名和学生名只包含字母，且一个学生在一个课程中不会出现两次成绩。输入保证课程数量不超过1000门，且每门课的学生数量不超过100人。输入不保证任何顺序。

第n+2行：一个整数m，代表查询的个数，即课程组的组数。1 <= m <= 10

接下来m行：每行是一个课程组，第一个整数k代表该组课程的数量，1 <= k <= 100，后面有k个字符串，表示k个课程名。整数k和字符串之间均用一个空格分隔。数据保证课程名一定在之前出现过。
## 输出
输出为m行，每行对应一个课程组，输出该组课程平均分最高的学生，只考虑学过该组全部课程的学生。如果平均分最高的学生多于一个，输出姓名按英文词典排序最靠前的学生。数据保证对每组课程，都存在学过该组所有课程的学生。
## 样例输入
```
22
JiSuanGaiLunA XiaoWang 100
JiSuanGaiLunA XiaoZhang 98
JiSuanGaiLunA XiaoHong 95
GaoDengShuXue XiaoHong 95
GaoDengShuXue XiaoZhang 84
GaoDengShuXue XiaoWang 82
GaoDengShuXue XiaoHuang 88
MeiRenLiJieJiSuanJiXiTong XiaoWang 82
MeiRenLiJieJiSuanJiXiTong XiaoZhang 84
MeiRenLiJieJiSuanJiXiTong XiaoHong 99
MeiRenLiJieJiSuanJiXiTong XiaoDuan 100
PythonCongRuMengDaoFangQi HYL 100
PythonCongRuMengDaoFangQi SWE 98
PythonCongRuMengDaoFangQi CDW 95
PythonCongRuMengDaoFangQi ASC 92
PythonCongRuMengDaoFangQi DEF 90
GuHanYu HYL 95
GuHanYu ASC 90
GuHanYu CDW 86
CollegeEnglish SWE 82
CollegeEnglish CDW 85
CollegeEnglish DEF 82
3
3 JiSuanGaiLunA GaoDengShuXue MeiRenLiJieJiSuanJiXiTong
2 PythonCongRuMengDaoFangQi GuHanYu
2 PythonCongRuMengDaoFangQi CollegeEnglish
```
## 样例输出
```
XiaoHong
HYL
CDW
```
# Solution
我也忘了我用CPP咋做的，我去查查  
先将每个人学的课程存入一个map里面  
然后，再遍历（先遍历人，再遍历课程，这样更方便跳出循环）的时候直接先找出平均分，最后一遍sort，就完事了，优化了挺多的  
上机的时候我确实没想到相同的解法，但是想出了相似的解法（笑）  
就是直接用一个字典存，这个字典的元素是字典，每个字典存这个人所学的课程和相应分数,另一个字典存人名，不需要sort，直接特判就行
```py
n=int(input())
dict={}
name=[]
dict_2={}
for i in range(1,n+1):
    k=input().split()
    x=k[0]
    y=k[1]
    z=int(k[2])
    if y not in name:
        name.append(y)
    if y in dict:
        dict[y][x]=z
    else:
        dict[y]={}
        dict[y][x]=z
m=int(input())
for i in range(1,m+1):
    k=input().split()
    num=int(k[0])
    ma=0
    res=[]
    for j in name:
        temp=0
        flag=1
        for v in range(1,num+1):
            if k[v] in dict[j].keys():
                temp+=dict[j][k[v]]
            else:
                flag=0
                break
        temp=temp/num
        if flag==0:
            continue
        if temp>ma:
            ma=temp
            res.clear()
            res.append(j)
        elif temp==ma:
            res.append(j)
    res.sort()
    print(res[0])
```
# 09:密码强度
## 描述
校内更新了刷卡机系统，为确保同学们的资金安全，要求设置具有一定强度的密码。符合要求的密码长度需要大于8，注意，是大于8，且必须包含特殊字符（"#"、"*"、或"&"）、字母和数字（字母既可以是大写字母也可以是小写字母）。现需要校验所输入的密码强度是否符合要求。

## 输入
为多行字符串，每行为一个密码。每个密码长度不超过25个字符。
## 输出
对每个密码，强度符合要求输出“YES”，否则输出“NO”
## 样例输入
```
asdff1234AZ
asdff123#Z
a#j
```
## 样例输出
```
NO
YES
NO
```
# Solution
这题其实没难度，但是要注意一个点  
就是python中相应C++的while(cin>>n)要怎么写
```py
while True:
    try:
        lst=input()
        flag1=0
        flag2=0
        flag3=0
        flag4=0
        if len(lst)>8:
            flag3=1
        for i in range(0,len(lst)):
            if lst[i]=='#' or lst[i]=='*' or lst[i]=='&':
                flag1=1
            if lst[i]>='0' and lst[i]<='9':
                flag4=1
            if lst[i]>='a' and lst[i]<='z':
                flag2=1
            if lst[i]>='A' and lst[i]<='Z':
                flag2=1
        if flag1==1 and flag2==1 and flag3==1 and flag4==1:
            print("YES")
        else:
            print("NO")
    except EOFError:
        break
```
# 10:打印任意年份任意月份的日历
## 描述
给定公元year年month月，打印该月月历

## 输入
第一行一个输入整数n，表示有n组数据。  
后面n行，每行一组数据，是两个整数，分别代表year( 0 < year <= 100000）和month（数据合法，1<=month<=12），用空格隔开  
## 输出
对于每组数据：  
第一行输出月份（英文表示，首字母大写）和年份，用逗号隔开；  
第二行输出星期几， Sun Mon Tue Wed Thu Fri Sat，用\t隔开；  
接下来输出当月日期，日期用\t隔开，第一周缺天直接输出\t。  
（行与行之间无空行，每组数据之间无空行）
行末多出来\t没有关系  
12个月份的单词是：  
"January","February", "March", "April", "May", "June", "July", "August", "September", "October","November", "December"
## 样例输入
```
3
2019 12
403 5
23456 7
```
## 样例输出
```
December,2019
Sun	Mon	Tue	Wed	Thu	Fri	Sat
1 	2 	3 	4 	5 	6 	7 	
8 	9 	10 	11 	12 	13 	14 	
15 	16 	17 	18 	19 	20 	21 	
22 	23 	24 	25 	26 	27 	28 	
29 	30 	31 	
May,403
Sun	Mon	Tue	Wed	Thu	Fri	Sat
				1 	2 	3 	
4 	5 	6 	7 	8 	9 	10 	
11 	12 	13 	14 	15 	16 	17 	
18 	19 	20 	21 	22 	23 	24 	
25 	26 	27 	28 	29 	30 	31 	
July,23456
Sun	Mon	Tue	Wed	Thu	Fri	Sat
		1 	2 	3 	4 	5 	
6 	7 	8 	9 	10 	11 	12 	
13 	14 	15 	16 	17 	18 	19 	
20 	21 	22 	23 	24 	25 	26 	
27 	28 	29 	30 	31
```
# Solution 
这道题公元1年1月1日是星期几需要我们自己推  
一般是星期六或者星期一，这道题是星期一，我们需要调整现在的参数来推测之前的内容  
还有就是，不要忘了打每个数据完了之后的换行符  
```py
def pd(x):
    if x%4==0 and x%100!=0:
        return True
    if x%400==0:
        return True
    return False

n=int(input())
rc=[0,31,29,31,30,31,30,31,31,30,31,30,31,30]
c=[0,31,28,31,30,31,30,31,31,30,31,30,31,30]
name=[0,"January","February","March","April","May","June","July","August","September","October","November","December"]
name_1=[0,"Sun","Mon","Tue","Wed","Thu","Fri","Sat"]
for i in range(1,n+1):
    lst=input().split()
    y=int(lst[0])
    m=int(lst[1])
    print(f"{name[m]},{y}")
    for j in range(1,8):
        if j<=6:
            print(name_1[j],end='\t')
        else:
            print(name_1[j])
    day=0
    if pd(y):
        for j in range(1,m):
            day+=rc[j]
        d=rc[m]
    else:
        for j in range(1,m):
            day+=c[j]
        d=c[m]
    tem=(y-1)//4+(y-1)//400-(y-1)//100
    day+=tem*366+(y-1-tem)*365
    temp=(day+1)%7
    ma=temp%7+1
    for j in range(1,ma):
        print('\t',end="")
    for j in range(1,d+1):
        print(j,end='\t')
        if ma>=7 and j!=d:
            ma=0
            print()
        ma+=1
    print()
```