---
title: 【程序设计实习】第四次上机复盘
date: 2025-03-30
categories:
    - 程序设计实习
---
# 05:正整数的任意进制转换
将 p 进制 n 转换为 q 进制。p 和 q 的取值范围为[2，36]，其中，用到的数码按从小到大依次为：0，1，2，3，4，5，6，7，8，9，A，B，...，Z，不考虑小写字母。
## 输入
一共1+m 行：  
第1行为 m，表示后面有 m 行（1 <= m <= 60）.  
其后的m行中，每行3个数: 进制p，p进制数n，以及进制 q。  
三个数之间用逗号间隔。  
n 的长度不超过50位。  
## 输出
转换后的 q 进制数。
## 样例输入
```
6
18,2345678A123,18
15,23456,18
12,2345678,20
16,12345678,23
25,3456AB,21
18,AB1234567,22
```
## 样例输出
```
2345678A123
114E0
22B7A4
21A976L
7C2136
22JF0G367
```
# Solution
就是简单的值 而且python还用不到高精度  
事情在于“0”要特判 直接输出0  
然后上代码：  
```
n=int(input())
di=[0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
dict={'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'A':10,'B':11,'C':12,'D':13,'E':14,'F':15,'G':16,'H':17,'I':18,'J':19,'K':20,'L':21,'M':22,'N':23,'O':24,'P':25,'Q':26,'R':27,'S':28,'T':29,'U':30,'V':31,'W':32,'X':33,'Y':34,'Z':35}
for i in range(0,n):
    lst=input().split(',')
    p=int(lst[0])
    x=lst[1]
    q=int(lst[2])
    num=0
    k=1
    l=[]
    t=x[::-1]
    for j in range(0,len(t)):
        num+=k*dict[t[j]]
        k*=p
    if(num==0):
        print('0')
        continue
    while(num>0):
        temp=num%q
        l.append(di[temp])
        num//=q
    res=l[::-1]
    for j in res:
        print(j,end='')
    print()
```
# 06:古代密码
## 描述
古罗马帝国有一个拥有各种部门的强大政府组织。其中一个部门就是保密服务部门。为了保险起见，在省与省之间传递的重要文件中的大写字母是加密的。当时最流行的加密方法是替换和重新排列。  
替换方法是将所有出现的字符替换成其它的字符。有些字符会替换成它自己。例如：替换规则可以是将'A' 到 'Y'替换成它的下一个字符，将'Z'替换成 'A'，如果原词是 "VICTORIOUS" 则它变成 "WJDUPSJPVT"。  
排列方法改变原来单词中字母的顺序。例如：将顺序例如将顺序 < 2 1 5 4 3 7 6 10 9 8 > 应用到 "VICTORIOUS" 上，则得到"IVOTCIRSUO"。  
人们很快意识到单独应用替换方法或排列方法加密，都是很不保险的。但是如果结合这两种方法，在当时就可以得到非常可靠的加密方法。所以，很多重要信息先使用替换方法加密，再将加密的结果用排列的方法加密。用两种方法结合就可以将"VICTORIOUS" 加密成"JWPUDJSTVP"。  
考古学家最近在一个石台上发现了一些信息。初看起来它们毫无意义，所以有人设想它们可能是用替换和排列的方法被加密了。人们试着解读了石台上的密码，现在他们想检查解读的是否正确。他们需要一个计算机程序来验证，你的任务就是写这个验证程序。  
## 输入
输入有两行。第一行是石台上的文字。文字中没有空格，并且只有大写英文字母。第二行是被解读出来的加密前的文字。第二行也是由大写英文字母构成的。  
两行字符数目的长度都不超过100。
## 输出
如果第二行经过某种加密方法后可以产生第一行的信息，输出 "YES"，否则输出"NO"。
## 样例输入
```
JWPUDJSTVP
VICTORIOUS
```
## 样例输出
```
YES
```
# Solution
既然交换的顺序和原先的字母代替顺序我们都不清楚，那么怎么办？  
能肯定的一点：同一个字母不管怎么弄都还是一样的字母  
那我们只需要对不同的字母计数 然后把字典的键擦除，再比对  
下面看代码：
```
x=input()
y=input()
dict_1={}
dict_2={}
for i in range(0,len(x)):
    if x[i] not in dict_1:
        dict_1[x[i]]=1
    else:
        dict_1[x[i]]+=1
for i in range(0,len(y)):
    if y[i] not in dict_2:
        dict_2[y[i]]=1
    else:
        dict_2[y[i]]+=1
list_1=[]
list_2=[]
for i in dict_1.values():
    list_1.append(i)
for i in dict_2.values():
    list_2.append(i)
list_1.sort()
list_2.sort()
flag=1
for i in range(0,max(len(list_1),len(list_2))):
    if list_1[i]==list_2[i]:
        continue
    else:
        flag=0
        break
if flag==0:
    print("NO")
else:
    print("YES")
```
# 07:啤酒厂选址
## 描述
海上有一个岛，在环海边上建有一条环岛高速公路，沿着公路有n（5 < n < 10000）个居民点，假设每个居民点有一个编号，从0开始，按顺时针依次从小到大（即，0,1，…，n-1）编号。在岛上啤酒很受青睐。某啤酒企业计划在岛上投资建一个啤酒厂，并根据啤酒需求每天向居住点送啤酒。已知两个相邻的居民点的距离以及每个居住点每天的啤酒需求量（假设每个居住点每天不超过2000桶）。假定每单位长度的路程送一桶啤酒需要的费用恒定（为单位费用）。请问，选择哪一个居民点建啤酒厂，才能使每天送啤酒的费用最小（空车不计费用）。
## 输入
第一行：为居民点数目n  
后面为n行，每行为一个居民点的啤酒需求量以及按顺时针离下一个居民点的距离（均为整数,空格间隔），从编号为0的开始，按单增顺次给出。  
注意：后面第n行对应于居民点（n-1)的啤酒需求量以及到编号为0的居民点距离。  
## 输出
啤酒厂所在的居民点编号以及每天的运输费用，其间以逗号间隔
## 样例输入
```
6
500 10
300 30
350 25
400 60
700 28
200 35
```
## 样例输出
```
0,94100
```
# Solution
简单前缀和加上模拟不解释 计概出过一模一样的题目，怕你忘了
```
n=int(input())
d=[0]
l=0
beer=[]
ans=1e8
mi=0
for i in range(1,n+1):
    lst=input().split()
    x=int(lst[0])
    y=int(lst[1])
    if(i!=n):
        d.append(d[i-1]+y)
    beer.append(x)
    l+=y
for i in range(0,n):
    temp=0
    for j in range(0,n):
        if i==j:
            continue
        else:
            temp+=beer[j]*min(abs(d[j]-d[i]),l-abs(d[j]-d[i]))
    if temp<ans:
        mi=i
        ans=temp
print(mi,end=',')
print(ans)
```
# 09:Minecraft
## 描述
Minecraft是一个几乎无所不能的沙盒游戏，玩家可以利用游戏内的各种资源进行创造，搭建自己的世界。  
在Minecraft中，基本的建筑元素是边长为1个单位的立方体，Tony想用N个这种小立方体搭建一个长方体，并用他珍藏已久的贴纸对其进行装饰。如果一张贴纸可以贴满小立方体的一个面。那么，他需要用掉多少张贴纸呢？  
## 输入
一个整数N，表示小明所拥有的小立方体的个数。N不会超过1000。
## 输出
一个整数，即小明最少用掉的贴纸有多少张。
## 样例输入
```
9
```
## 样例输出
```
30
```
# Solution:
我们要优化时间复杂度 假设最小性
```
n=int(input())
ans=1e8
for i in range(1,n+1):
    if i*i*i>n:
        break
    for j in range(i,n+1):
        for k in range(j,n+1):
            if n==i*j*k:
                ans=min(ans,2*(i*j+j*k+k*i))
print(ans)
```
# 10:猴子吃桃
## 描述
海滩上有一堆桃子，N只猴子来分。第一只猴子把这堆桃子平均分为N份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子接着把剩下的桃子平均分成N份，又多了一个，它同样把多的一个扔入海中，拿走了一份。第三、第四、……，第N只猴子仍是最终剩下的桃子分成N份，扔掉多了的一个，并拿走一份。  
编写程序，输入猴子的数量N，输出海滩上最少的桃子数，使得每只猴子都可吃到桃子。
## 输入
一个整数N。
## 输出
输出当猴子数量为N时海滩上最少的桃子数。结果保证在int型范围内。
## 样例输入
```
2
```
## 样例输出
```
7
```
# Solution
是小学奥数，但是不要被吓到  
计算机是很强的！  
还是个枚举题 但是枚举最终结果太超模了  
所以枚举最后剩下的  
完事
- ### 笔者注：这题可以用瞪眼法找规律
```
n=int(input())
for i in range(1,2147483647):
    ans=i*n+1
    flag=0
    for j in range(0,n-1):
        if ans%(n-1)==0:
            ans=ans*n//(n-1)+1
            if j==n-2:
                flag=1
                break
            else:
                continue
        else:
            break
    if flag==1:
        print(ans)
        break
```